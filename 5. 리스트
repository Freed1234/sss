# # 소수 여부를 확인하는 함수 정의
# def isPrime(N):
#     # 2부터 N-1까지의 수로 나누어 떨어지는지 확인
#     for i in range(2, N):
#         # 나누어 떨어진다면 소수가 아님
#         if N % i == 0:
#             return False
#     # 모든 반복이 끝나면 소수로 판단
#     return True

# # 소수를 저장할 빈 리스트 생성
# list = []

# # 2부터 100까지의 수에 대해 반복
# for i in range(2, 101):
#     # 해당 수가 소수인지 확인
#     if isPrime(i):
#         # 소수라면 리스트에 추가
#         list.append(i)

# # 소수 리스트 출력
# print(list)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 5.20


# # 주어진 문자열
# src = "accccccbbbbbbbbbbbcccccccccchhhhhhhhhhhhkkkkkkkkkkkkeeeeeeeeeeeeeoddddddddddddpp"
# # 결과 문자열
# out = ""

# # 첫 번째 문자를 out에 추가
# x = src[0]
# out = out + x
# # 문자열 카운트 변수 초기화
# count = 0

# # 문자열 순회
# for ch in src:
#     # 현재 문자와 이전 문자가 같으면 count 증가
#     if x == ch:
#         count = count + 1
#     # 현재 문자와 이전 문자가 다르면 out에 이전 문자의 count와 현재 문자 추가
#     else:
#         out = out + str(count) + ch
#         # 이전 문자를 현재 문자로 변경하고 count 초기화
#         x = ch
#         count = 1

# # 마지막 문자의 count를 out에 추가
# out = out + str(count)

# # 결과 출력
# print(src)
# print(out)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 다양한 방법으로 리스트 만들기


# list1 = list() # 빈 리스트 생성하기

# list2 = [] # 빈 리스트 생성하기

# list3 = list((1, 2, 3)) # 튜플로부터 리스트 생성
# print(list3)

# list4 = list(range(1, 10)) # range() 함수로부터 리스트 생성
# print(list4)

# list5 = list('ABCDF') # 문자열로부터 리스트 생성
# print(list5)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 5-1: 리스트의 생성


# even_list = [2, 4, 6, 8, 10]  # 짝수 리스트 생성
# print("even_list =", even_list)  # 짝수 리스트 출력

# even_list2 = list(range(2, 11, 2))  # range 함수와 list 함수를 이용해 짝수 리스트 생성
# print("even_list2 =", even_list2)  # 생성한 짝수 리스트 출력

# nations = ['korea', 'china', 'india', 'nepal']  # 국가 이름 리스트 생성
# print("nations =", nations)  # 국가 이름 리스트 출력

# friends = ['길동', '철수', '연지', '지은', '영민']  # 친구 이름 리스트 생성
# print("friend =", friends)  # 친구 이름 리스트 출력

# string = list('XYZ')  # 문자열을 리스트로 변환
# print(string)  # 변환한 리스트 출력

# input_string = 'XYZ'  # 입력 문자열 정의
# string = list(input_string)  # 입력 문자열을 리스트로 변환
# print(string)  # 변환한 리스트 출력


# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트 인덱스를 통한 요소의 접근


# n_list = [11, 22, 33, 44, 55, 66] # 6개의 요소를 가진 리스트

# print(len(n_list)) # 리스트의 요소의 개수를 구하는 함수

# print(n_list[0]) # 리스트의 첫 번째 항목의 인덱스는 0이다

# print(n_list[1]) # 리스트의 두 번째 항목의 인덱스는 1이다

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트의 음수 인덱스 사용법


# n_list = [11, 22, 33, 44, 55, 66]

# print(n_list[-1]) # 리스트의 마지막 요소 값

# print(n_list[-2])

# print(n_list[-3])

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 5-2: 리스트의 생성과 인덱싱


# prime_list = [2, 3, 5, 7]  # 소수 리스트 생성

# print(prime_list[0])  # 리스트의 첫 번째 원소 출력 (결과: 2)
# print(prime_list[3])  # 리스트의 네 번째 원소 출력 (결과: 7)
# print(prime_list[-1])  # 리스트의 마지막 원소 출력 (결과: 7)

# nations = ["korea", "china", "russia", "malaysia"]  # 국가 이름 리스트 생성

# print(nations[0])  # 리스트의 첫 번째 원소 출력 (결과: "korea")
# print(nations[-1])  # 리스트의 마지막 원소 출력 (결과: "malaysia")
# print(nations[len(nations)-1])  # 리스트의 길이를 이용해 마지막 원소 출력 (결과: "malaysia")


# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트의 append() 메소드를 사용한 항목의 추가


# a_list = ['print(, 'b', 'c', 'd', 'e']
# a_list.append('f') # 'f' 항목 추가
# print(a_list)

# n_list = [10, 20, 30, 40]
# n_list.append(50) # 50 항목 추가
# print(n_list)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# del 명령어를 통한 리스트의 항목 삭제


# n_list = [11, 22, 33, 44, 55, 66]
# print(n_list) # 전체 항목 출력

# del n_list[3] # 네 번째 항목(44) 삭제
# print(n_list)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# remove() 메소드를 이용한 리스트의 항목 삭제


# n_list = [11, 22, 33, 44, 55, 66]
# print(n_list)

# n_list.remove(44) # 44라는 값을 가진 항목 삭제
# print(n_list)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 멤버 연산자 in과 not in


# a_list = [10, 20, 30, 40]

# print(10 in a_list) # 리스트의 요소로 10이 있으므로 참

# print(50 in a_list) # 리스트의 요소로 50이 없으므로 거짓

# print(10 not in a_list)

# print(50 not in a_list)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# in 연산자를 이용한 안전한 원소 삭제


# n_list = [11, 22, 33, 44, 55, 66]

# if (55 in n_list): # 리스트의 요소로 55가 있을 경우
#     n_list.remove(55) # 리스트에서 55를 삭제함

# if (88 in n_list): # 리스트의 요소로 88이 있을 경우
#     n_list.remove(88) # 리스트에서 88을 삭제함

# print(n_list)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 5-3: 리스트의 삽입과 삭제, in 연산자


# prime_list = [2, 3, 5, 7]  # 소수 리스트 생성

# prime_list.append(11)  # 리스트에 11 추가
# print(prime_list)  # 리스트 출력

# prime_list.remove(3)  # 리스트에서 3 제거
# print(prime_list)  # 리스트 출력

# nations = ['korea', 'china', 'russia', 'malaysia']  # 국가 이름 리스트 생성

# nations.append('nepal')  # 리스트에 'nepal' 추가

# # 리스트에 'japan'이 있는지 확인
# if ('japan' in nations):
#     print("japan 은 국가 목록에 있습니다.")
# elif ('japan' not in nations):
#     print("japan 은 국가 목록에 없습니다.")

# # 리스트에 'russia'가 있는지 확인
# if ('russia' in nations):
#     print("russia 는 국가 목록에 있습니다.")
# elif ('russia' not in nations):
#     print("russia 는 국가 목록에 없습니다.")

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트와 내장함수 min(), max(), sum()


# list1 = [20, 10, 40, 50, 30]

# min(list1) # 리스트의 원소들 중 가장 작은 원소를 구합니다.

# max(list1) # 리스트의 원소들 중 가장 큰 원소를 구합니다.

# sum(list1) # 리스트 내의 원소의 합을 구합니다.

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 문자열 리스트와 내장함수 min(), max()


# fruits = ['banana', 'orange', 'apple', 'kiwi']

# min(fruits) # 영어사전 순서로 가장 앞에 있는 철자를 가진 단어를 반환

# max(fruits) # 영어사전 순서로 가장 뒤에 있는 철자를 가진 단어를 반환

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 한글 문자열 리스트와 내장함수 min(), max()


# k_fruits = ['사과', '오렌지', '포도', '바나나']

# min(k_fruits) # 국어사전 순서로 가장 앞에 있는 단어를 반환

# max(k_fruits) # 국어사전 순서로 가장 뒤에 있는 단어를 반환

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 5-4: 리스트의 min()과 max(), sum(), len() 함수


# prime_list = [1, 2, 3, 5, 7]  # 소수 리스트 생성

# print(min(prime_list))  # 리스트의 최소값 출력 (결과: 1)
# print(max(prime_list))  # 리스트의 최대값 출력 (결과: 7)
# print(sum(prime_list))  # 리스트의 합 출력 (결과: 18)

# a = sum(prime_list)  # 리스트의 합 계산
# b = len(prime_list)  # 리스트의 길이 (원소의 개수) 계산
# print(a/b)  # 평균 출력 (결과: 18/5 = 3.6)

# nation_list = ["korea", "china", "russia", "malaysia"]  # 국가 이름 리스트 생성

# print(min(nation_list))  # 리스트에서 사전 순서상 가장 빠른 문자열 출력 (결과: "china")
# print(max(nation_list))  # 리스트에서 사전 순서상 가장 늦은 문자열 출력 (결과: "russia")

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

#리스트와 sort() 메소드


# list = [20, 10, 40, 30, 50]

# list.sort() # list의 원소를 오름차순 정렬

# print(list)


# list.sort(reverse = True) # # list의 원소를 내림차순 정렬

# print(list)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트의 메소드와 하는 일


# ex_list = [1, 2, 3]

# ex_list.index(x) # 원소 x를 이용하여 위치를 찾는 기능을 한다.
# ex_list.append(x) # 원소 x를 리스트의 끝에 추가한다.
# ex_list.count(x) # 리스트 내에서 x 원소의 개수를 반환한다.
# ex_list.extend([x1, x2]) # [x1, x2] 리스트를 리스트에 삽입한다.
# ex_list.insert(index, x) # 원하는 index 위치에 x를 추가한다.
# ex_list.remove(x) # x 원소를 리스트에서 삭제한다.
# ex_list.pop(index) # index 위치의 원소를 삭제한 후 반환한다. 이때 index는 생략될 수 있으며 이 경우 리스트의 마지막 원소를 삭제하고 이를 반환한다.
# ex_list.sort() # 값을 오름차순 순서대로 정렬한다. reverse 인자의 값이 True이면 내림차순으로 정렬한다.
# ex_list.reverse() # 리스트를 원래 원소들의 역순으로 만들어 준다.

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 원소의 인덱스를 반환하는 index() 메소드


# a_list = ['a', 'b', 'c', 'd', 'e']

# print(a_list.index('a')) # 'a' 원소의 인덱스를 반환한다.
# print(a_list.index('b')) # 'b' 원소의 인덱스를 반환한다.
# print(a_list.index('x')) # 존재하지 않는 'x' 원소의 인덱스를 조회: 오류 발생

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트의 count() 메소드


# b_list = ['a', 'b', 'c', 'd', 'e']

# print(b_list.count('a')) # 'a'가 몇 개 있는지 그 개수를 반환
# print(b_list.count('b')) # 'b'가 몇 개 있는지 그 개수를 반환

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# *주의* append() 메소드와 extend() 메소드의 차이점


# 만일 아래의 list1에 append() 를 시도하게 되면 우리가 흔히 생각하는 [11, 22, 33, 44, 55, 66]의 결과가 나오지 않는다. list1.append([55, 66]) 메소드를 호출하면 [55, 66]이라는 리스트 항목을 [11, 22, 33, 44] 다음에 추가하여 list1은 [11, 22, 33, 44 [55, 66]]이라는 항목을 가지게 된다.

# list1 = [11, 22, 33, 44]
# list1.append([55, 66])
# print(list1) # 리스트 항목의 수는 5개

# 만일 리스트 내에 새로운 리스트의 항목을 추가하고자 할 경우에는 extend() 메소드를 사용할 수 있다.

# list1 = [11, 22, 33, 44]
# list1.extend([55, 66])
# print(list1) # 리스트 항목의 수는 6개

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트의 insert() 메소드


# list1 = ['a', 'c', 'd']
# list1.insert(1, 'b') # 첫번째 인덱스 위치에 b 삽입
# print(list1)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트의 remove() 메소드


# list1 = ['a', 'b', 'c', 'b', 'd']
# list1.remove('b') # 제일 먼저 나타나는 'b' 원소를 삭제함
# print(list1)

# list1.remove('b') # list1에 있는 'b' 원소를 삭제함
# print(list1)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트의 pop() 메소드


# list1 = ['a', 'b', 'c', 'd']
# print(list1.pop()) # list1의 마지막 원소 'd' 를 삭제하고 반환

# print(list1) # 결과: ['a', 'b', 'c']

# list1 = ['a', 'b', 'c', 'd']
# print(list1.pop(1)) # list1 의 두 번째 원소 'b'를 삭제하고 반환
# # 결과: b

# print(list1) # 결과: ['a', 'c', 'd']

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# remove()와 인덱스를 이용한 마지막 원소의 삭제


# list1 = ['a', 'b', 'c', 'd']
# list1.remove(list1[-1]) # pop()과 유사하게 리스트의 마지막 원소 삭제
# print(list1)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트의 reverse() 메소드


# list1 = [10, 20, 30, 40]
# list1.reverse() # 리스트의 원소를 역순으로 다시 배열함
# print(list1)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 5-5: 리스트 메소드의 응용


# # 두 리스트를 합치는 방법 비교: append vs extend
# a = [1, 2, 3]
# b = [10, 20, 30]
# a.append(b)  # append를 사용하면 b 리스트 자체가 a 리스트의 마지막 요소로 추가됨
# print(a) # 결과: [1, 2, 3, [10, 20, 30]]

# a = [1, 2, 3]
# b = [10, 20, 30]
# a.extend(b)  # extend를 사용하면 b 리스트의 각 요소가 a 리스트의 요소로 추가됨
# print(a) # 결과: [1, 2, 3, 10, 20, 30]

# # 1~10 까지의 리스트 만들기
# nlist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# print(nlist)

# nlist.insert(0, 0)  # 리스트의 첫 번째 위치에 0을 삽입
# print(nlist)

# nlist.reverse()  # 리스트의 요소 순서를 뒤집음
# print(nlist)

# # 리스트에서 마지막 요소를 제거하고 반환하는 방법
# print("마지막 원소: ", nlist.pop(-1))  # 리스트의 마지막 요소를 제거하고 그 요소를 반환
# print(nlist)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 두 리스트를 합치는 연산자 +


# list1 = [11, 22, 33, 44]
# list2 = [55, 66]

# print(list1) # 결과: [11, 22, 33, 44]
# print(list1 + list2) # 결과: [11, 22, 33, 44, 55, 66]

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 두 리스트를 합치는 연산자 +를 이용하여 그 결과를 저장함


# list1 = [11, 22, 33, 44]
# list2 = [55, 66]

# list3 = list1 + list2
# print(list3) # 결과: [11, 22, 33, 44, 55, 66]

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# * 연산자를 이용한 반복 리스트


# list1 = [1, 2, 3, 4]
# print(list1 * 2) # 결과 [1, 2, 3, 4, 1, 2, 3, 4]

# list2 = list1 * 3 # list * 3의 결과를 list2에 할당
# print(list2) # 결과: [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 문법오류를 유발하는 두 리스트의 * 연산


# list1 = [1, 2, 3, 4]
# list2 = [10, 20, 30]
# print(list1 * list2) # 결과: 오류 발생

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# == 연산자를 이용한 리스트의 비교


# list1 = [1, 2, 3, 4]
# list2 = [1, 2, 3, 4]
# print(list1 == list2) # 결과: True

# list3 = [4, 1, 2, 3]
# print(list1 == list3) # 결과: False

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# >, < 연산자를 이용한 리스트의 비교


# list1 = [1, 2, 3, 4]
# list2 = [2, 3, 3, 4]

# print(list1 > list2) # 결과: False
# print(list1 < list2) # 결과: True

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 5-6: 리스트 연산


# n = int(input("반복할 정수를 입력하시오: "))

# list1 = [1, 2, 3]
# print(list1 * n)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트 요소들을 하나하나 방문하며 10을 곱하는 기능


# list1 = [10, 20, 30, 40, 50]  # 초기 리스트 설정
# i = 0  # 인덱스 초기화
# for n in list1:  # 리스트의 각 요소에 대해 반복
#     list1[i] = n * 10  # 현재 요소를 10배로 만든 후, 원래 위치에 다시 저장
#     i = i + 1  # 인덱스 업데이트

# print(list1)  # 업데이트된 리스트 출력

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트의 축약 표현을 사용하여 10을 곱하는 기능


# list1 = [10, 20, 30, 40, 50]
# list1 = [n * 10 for n in list1]
# print(list1) # 결과: [100, 200, 300, 400, 500]

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 람다함수와 map을 이용하여 리스트 요소들을 조작하기


# 초기 정수 리스트 설정
list1 = [10, 20, 30, 40, 50]  

# map 함수를 사용하여 list1의 각 원소에 대해 람다 함수를 적용
# 람다 함수 lambda x: x * 10는 입력값 x에 대해 x * 10을 계산하는 함수
# 이 결과는 map 객체로 반환되며, 이를 다시 list 함수를 사용하여 리스트로 변환
list1 = list(map(lambda x: x * 10, list1))  

# 변환된 리스트 출력
print(list1) # 결과: [100, 200, 300, 400, 500]

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 슬라이싱 문법과 하는 일
# *주의* 슬라이싱을 할 때 콜론(:) 뒤에 명시한 마지막 인덱스는 슬라이싱 리스트에 포함하지 않는다.


# print(ex_list[start:end]) # start부터 end-1 까지의 항목들을 슬라이싱
# print(ex_list[start:]) # start부터 리스트의 끝까지, 즉 뒷부분 모두를 슬라이싱
# print(ex_list[:end]) # 처음부터 end-1번째 인덱스 항목을 슬라이싱
# print(ex_list[:]) # 전체를 슬라이싱
# print(ex_list[start:end:step]) # start부터 end-1까지를 step만큼 건너뛰며 슬라이싱
# print(ex_list[-2:]) # 뒤에서부터 두 개의 항목을 슬라이싱
# print(ex_list[:-2]) # 처음부터 끝의 두 개를 제외한 모든 항목을 슬라이싱
# print(ex_list[::-1]) # 모든 항목을 역순으로 가져옴
# print(ex_list[1::-1]) # 처음 두 개 항목을 역순으로 슬라이싱

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트와 슬라이싱
# *주의* 슬라이싱을 할 때 콜론(:) 뒤에 명시한 마지막 인덱스는 슬라이싱 리스트에 포함하지 않는다.

# a_list = [10, 20, 30, 40, 50, 60, 70, 80]
# print(a_list[1:5]) # 결과: [20, 30, 40, 50]
# print(a_list[0:1]) # 결과: [10]
# print(a_list[0:2]) #결과: [10, 20]
# print(a_list[0:5]) #결과: [10, 20, 30, 40, 50]
# print(a_list[1:]) # 결과: [20, 30, 40, 50, 60, 70, 80]
# print(a_list[:5]) # 결과: [10, 20, 30, 40, 50]

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 5-7: 리스트의 슬라이싱


# n_list = list(range(0, 15))  # 0부터 14까지의 숫자로 이루어진 리스트를 생성합니다.

# s_list1 = n_list[:5]  # n_list의 첫 번째 원소부터 다섯 번째 원소까지 슬라이스합니다.
# s_list2 = n_list[5:11]  # n_list의 여섯 번째 원소부터 열 한 번째 원소까지 슬라이스합니다.
# s_list3 = n_list[11:15]  # n_list의 열 두 번째 원소부터 열 다섯 번째 원소까지 슬라이스합니다.
# s_list4 = n_list[2:11:2]  # n_list의 세 번째 원소부터 열 한 번째 원소까지, 두 칸씩 건너뛰며 슬라이스합니다.
# s_list5 = n_list[-5:-10:-1]  # n_list의 뒤에서 다섯 번째 원소부터 뒤에서 열 번째 원소까지 역순으로 슬라이스합니다.
# s_list6 = n_list[-5:-15:-2]  # n_list의 뒤에서 다섯 번째 원소부터 처음까지, 두 칸씩 건너뛰며 역순으로 슬라이스합니다.

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 5.24


# 주어진 수의 약수를 찾는 함수 정의
# def get_divisior(N):
#     divisior = []  # 약수를 저장할 리스트 초기화
#     for i in range(1, N):  # 1부터 N-1까지 반복
#         if N%i == 0:  # N이 i로 나누어 떨어지면 (즉, i가 N의 약수면)
#             divisior.append(i)  # i를 약수 리스트에 추가
#     return divisior  # 약수 리스트 반환

# # 2부터 10000까지의 완전수를 찾는 코드
# for i in range(2, 10001):  # 2부터 10000까지 반복
#     if sum(get_divisior(i)) == i: # i의 약수들의 합이 i와 같으면 (즉, i가 완전수면)
#         print(i)  # i 출력
