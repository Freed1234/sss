# animals 리스트 객체와 다양한 메소드


animals = ['lion', 'tiger', 'cat', 'dog']

animals.sort()
print(animals)

animals.append('rabbit')
print(animals)

animals.reverse()
print(animals)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 리스트 객체의 pop() 메소드와 스트링 객체의 upper() 메소드


# animals = ['lion', 'tiger', 'cat', 'dog']

s = animals.pop()
print(s)

print(s.upper())

print(s.find('a'))

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# Cat 클래스 정의와 인스턴스 생성 문법


# class Cat: # Cat 클래스의 정의
#     pass

# nabi = Cat() # Cat 인스턴스 생성
# print(nabi)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# Cat 클래스 정의와 meow() 메소드


# class Cat:
#     def meow(self):
#         print('야옹 야옹~~')

# nabi = Cat()
# nabi.meow()

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# Cat 클래스 정의와 여러 개의 객체 생성


# class Cat:
#     def meow(self):
#         print('야옹 야옹~~')

# nabi = Cat()
# nabi.meow()
# nero = Cat()
# nero.meow()
# mimi = Cat()
# mimi.meow()

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 9-4: Dog 클래스와 인스턴스 생성




# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 생성자를 가진 Cat 클래스의 정의와 인스턴스 생성


# class Cat:
#     def __init__(self, name, color): # 생성자 혹은 초기화 메소드라 한다.
#         self.name = name # name이라는 인스턴스 변수를 생성
#         self.color = color # color이라는 인스턴스 변수를 생성

#     # 고양이의 정보를 출력하는 메소드
#     def meow(self):
#         print('내 이름은 {}, 색깔은 {}, 야옹야옹~~'.format(self.name, self.color))

# nabi = Cat('나비', '검정색') # nabi 인스턴스 생성
# nero = Cat('네로', '흰색') # nero 인스턴스 생성
# mimi = Cat('미미', '갈색') # mimi 인스턴스 생성

# nabi.meow()
# nero.meow()
# mimi.meow()

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 클래스와 생성자의 디폴트 매개변수 값


# 파이썬은 클래스에 대해 하나의 생성자만을 허용한다. C++이나 Java와 같은 프로그래밍 언어는 여러가지 형태의 생성자를 허용하고 이 때는 클래스의 이름을 중복 정의하여 사용할 수 있다. 이 때문에 위에서 만든 __init__() 메소드의 생성자 매개변수에 (self, name, color = '흰색'): 과 같이 color = '흰색' 형식의 디폴트 매개변수를 넣어주면, Cat('네로')와 Cat('네로', '흰색')을 모두 사용할 수 있다.

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 9-5: Dog 클래스와 인스턴스 생성

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# __str__ 메소드와 print() 함수에서 적용하기


# class Cat:
#     def __init__(self, name, color):
#         self.name = name
#         self.color = color

#     # Cat 객체의 문자열 표현 방식
#     def __str__(self):
#         return 'Cat(name = '+self.name+', color = '+self.color+')'


# nabi = Cat('나비', '검정색') # nabi 인스턴스 생성
# nero = Cat('네로', '흰색') # nero 인스턴스 생성

# print(nabi)
# print(nero)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 9-6: Dog 클래스와 문자열화 메소드

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# nabi.age에 직접 값을 할당하기


# class Cat:
#     def __init__(self, name, age):
#         self.name = name
#         self.age = age

#     def __str__(self):
#         return 'Cat(name = '+self.name+', age = '+str(self.age)+')'
    

# nabi = Cat('나비', 3)
# print(nabi)
# nabi.age = 4
# nabi.age = -5
# print(nabi)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# set_age() 메소드를 통해서 age 값을 할당하기


# class Cat:
#     def __init__(self, name, age):
#         self.name = name # Cat 클래스의 인스턴스 변수를 감추는 역할
#         self.age = age

#     # Cat의 문자열 표현방식
#     def __str__(self):
#         return 'Cat(name = '+self.__name+', age = '+str(self.__age)+')'
    
#     # self.__age를 외부에서 자유롭게 접근하는 것을 제한하고 음수가 되지 않도록 함
#     def set_age(self, age):
#         if age > 0:
#             self.__age = age

#     def get_age(self):
#         return self.__age

# nabi = Cat('나비', 3) # nabi 인스턴스 생성
# print(nabi)
# nabi.set_age(4) # set_age() 메소드를 통해서 age에 접근
# nabi.set_age(-5) # set_age() 메소드를 통해서 age가 음수가 되지 않도록 함
# print(nabi)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 객체의 아이덴티티 연산자: is, is not 연산자


# list_a = [10, 20, 30] # 리스트 객체를 참조하는 list_a
# list_b = [10, 20, 30] # 리스트 객체를 참조하는 list_b

# if list_a is list_b: # 두 리스트 객체가 같은지 검사함
#     print('list_a is list_b')
# else:
#     print('list_a in not list_b')

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 두 개의 리스트와 == 연산


# list_a = [10, 20, 30] # 리스트 객체를 참조하는 list_a
# list_b = [10, 20, 30] # 리스트 객체를 참조하는 list_b

# if list_a == list_b: # 리스트 객체의 속성 값이 같은지 비교함
#     print('list_a == list_b')
# else:
#     print('list_a != list_b')

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 두 개의 문자열 참조변수와 is, is not 연산


# a = 'ABC' # 문자열 객체를 참조하는 변수 a
# b = 'ABC' # 문자열 객체를 참조하는 변수 b

# if a is b: # 문자열 객체 a, b가 같은가 비교
#     print('a is b') # 문자열 객체 a, b는 같은 객체를 참조함
# else:
#     print('a is not b')

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 9-7: 정수 객체의 is 연산

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 사용자 정의 Vector2D 클래스와 + 연산


# class Vector2D:
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y

# v1 = Vector2D(30, 40)
# v2 = Vector2D(10, 20)

# v3 = v1 + v2 # Vector2D의 + 연산이 정의되지 않았다: 오류 출력
# print('v1 + v2 = ', v3)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# add() 메소드를 이용한 벡터의 덧셈


# class Vector2D:
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y

#     def __str__(self):
#         return '({}, {})'.format(self.x, self.y)
    
# v1 = Vector2D(30, 40)
# v2 = Vector2D(10, 20)

# v3 = v1.add(v2) # Vector2D의 add() 메소드 사용
# print('v1.add(v2) =', v3)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# __add__, __sub__, __str__ 특수 메소드와 연산자의 관계


# class Vector2D:
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y

#     def __add__(self, other):
#         return Vector2D(self.x + other.x, self.y + other.y)
    
#     def __sub__(self, other):
#         return Vector2D(self.x - other.x, self.y - other.y)
    
#     def __str__(self):
#         return '({}, {})'.format(self.x, self.y)
    
# v1 = Vector2D(30, 40)
# v2 = Vector2D(10, 20)

# v3 = v1 + v2
# print('v1 + v2 =', v3)
# v4 = v1 - v2
# print('v1 - v2 =', v4)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 파이썬의 대표적인 연산자와 이에 해당하는 특수 메소드


# x + y, __add__(self, other): x와 y의 합을 구한다.
# x - y, __sub__(self, other): x와 y의 합을 구한다.
# x * y, __mul__(self, other): x와 y의 곱을 구한다.
# x ** y, __pow__(self, other): x의 y의 거듭제곱을 구한다.
# x / y, __truediv__(self, other): x를 y로 나눈 값을 구한다.
# x // y, __floordiv__(self, other): x를 y로 나눈 나머지를 구한다.
# x % y, __mod__(self, other): x를 y로 나눈 나머지를 구한다.
# +x, __pos__(self): x를 구한다.
# -x, __neg__(self): x의 음수를 구한다.

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 파이썬의 비교 연산자와 이에 해당하는 특수 메소드


# x < y, __lt__(self, other): x가 y보다 작은가?
# x <= y, __le__(self, other): x가 y보다 작거나 같은가?
# x >= y, __ge__(self, other): x가 y보다 크거나 같은가?
# x > y, __gt__(self, other): x가 y보다 큰가?
# x == y, __eq__(self, other): x와 y가 같은가?
# x != y, __ne__(self, other): x와 y가 서로 다른가?

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 9-8: 특수 메소드의 응용

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 9-9: 벡터의 크기 비교하기

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# Circle 인스턴스와 속성 PI


# class Circle:
#     def __init__(self, name, radius, PI):
#         self.__name = name # 인스턴스 변수
#         self.__radius = radius # 인스턴스 변수
#         self.__PI = PI # 인스턴스 변수

#     def area(self):
#         return self.__PI * self.__radius ** 2
    
# c1 = Circle('C1', 4, 3.14)
# print('c1의 면적', c1.area())
# c2 = Circle('C2', 6, 3.141)
# print('C2의 면적', c2.area())
# c3 = Circle('C3', 5, 3.1415)
# print('C3의 면적', c3.area())

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# Circle 인스턴스와 클래스 변수 PI


# class Circle:
#     PI = 3.1415 # 클래스 변수
#     def __init__(self, name, radius):
#         self.__name = name # 인스턴스 변수
#         self.__radius = radius # 인스턴스 변수

    
#     # Circle 클래스의 변수 PI를 이용하여 면적을 구함
#     def area(self):
#         return Circle.PI * self.__radius ** 2
    

# c1 = Circle('c1', 4)
# print('c1의 면적', c1.area())
# c2 = Circle('c2', 6)
# print('c2의 면적', c2.area())
# c3 = Circle('c3', 5)
# print('c3의 면적', c3.area())

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# __dict__ 속성을 이용한 인스턴스변수와 값 알아보기


# class Circle:
#     PI = 3.14
#     def __init__(self, name, radius):
#         self.name = name
#         self.radius = radius

# c1 = Circle('C1', 4)
# print('c1의 속성들: ', c1.__dict__)
# # __dic__[key] 형식으로 value를 얻을 수 있음
# print('c1의 name 변수 값: ', c1.__dict__['name'])
# print('c1의 radius 변수 값: ', c1.__dict__['radius'])

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 언더스코어로 시작하는 인스턴스변수의 값 알아보기


# class Circle:
#     PI = 3.14
#     def __init__(self, name, radius):
#         self.__name = name
#         self.__radius = radius

# c1 = Circle('C1', 4)
# print('c1의 속성들: ', c1.__dict__)

# # __dic__[key] 형식으로 value를 얻을 수 있음
# print('c1의 __name 변수값: ', c1.__dict__['Circle__name'])
# print('c1의 __radius 변수값: ', c1.__dict__['Circle__radius'])

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 9-10: __dict__를 이용한 인스턴스변수의 조회

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
