# person 딕셔너리의 생성과 조회


# # '이름', '나이', '몸무게'를 키로 갖고 '홍길동', '26', '82'를 값으로 갖는 딕셔너리 생성
# person = {'이름': '홍길동', '나이': 26, '몸무게': 82}

# print(person['이름'])  # 출력: 홍길동
# print(person['나이'])  # 출력: 26
# print(person['몸무게'])  # 출력: 82

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 6-1: 딕셔너리의 생성


# coptical_dic = {'korea': 'seoul', 'china': 'beijing', 'usa': 'washington DC'} # 딕셔너리 생성

# print(coptical_dic['korea']) # 키: 'korea', 값: 'seoul'
# print(coptical_dic['china']) # 키: 'china', 값: 'beijing'
# print(coptical_dic['usa']) # 키: 'usa', 값: 'washington DC'


# fruits_dic = {'apple': 5000, 'banana': 4000, 'grape': 5300, 'melon': 6500}

# print(fruits_dic['apple']) # 키: 'apple', 값: 5000
# print(fruits_dic['banana']) # 키: 'banana', 값: 4000
# print(fruits_dic['grape']) # 키: 'grape', 값: 5300
# print(fruits_dic['melon']) # 키: 'melon', 값: 6500

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 딕셔너리의 항목 삽입


# person = {'이름': '홍길동', '나이': 26, '몸무게': 82}
# person['직업'] = '율도국의 왕' # 새로운 키:값 항목 삽입
# print(person) # 출력: {'이름': '홍길동', '나이': 26, '몸무게': 82, '직업': '율도국의 왕'}

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 딕셔너리의 항목 수정


# person = {'이름': '홍길동', '나이': 26, '몸무게': 82}
# person['나이'] = 27 # '나이' 항목의 값 수정
# print(person) # 출력: {'이름': '홍길동', '나이': 27, '몸무게': 82}

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 딕셔너리의 항목 삭제


# person = {'이름': '홍길동', '나이': 26, '몸무게': 82}
# del person['나이'] # '나이' 항목 삭제
# print(person) # 출력: {'이름': '홍길동', '몸무게': 82}

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 6-2: 딕셔너리의 항목 추가와 삭제


# person = {'이름': '홍길동', '나이': 26, '몸무게': 82}  # 딕셔너리 생성
# person['특기'] = '분신술'  # '특기'라는 새로운 키에 '분신술'이라는 값을 추가
# print(person)  # 출력: {'이름': '홍길동', '나이': 26, '몸무게': 82, '특기': '분신술'}

# person['아버지'] = '홍판서'  # '아버지'라는 새로운 키에 '홍판서'라는 값을 추가
# print(person)  # 출력: {'이름': '홍길동', '나이': 26, '몸무게': 82, '특기': '분신술', '아버지': '홍판서'}

# del person['나이']  # '나이' 키와 그에 연결된 값을 딕셔너리에서 제거
# print(person)  # 출력: {'이름': '홍길동', '몸무게': 82, '특기': '분신술', '아버지': '홍판서'}

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# in 연산자를 이용한 딕셔너리 항목의 조회
# *주의*: 딕셔너리에서 in 연산은 [키]가 특정 딕셔너리에 있는가를 조회할 수 있다. 아래와 같이 [값]에 해당하는 '홍길동'은 person 딕셔너리의 키 목록에 없기 때문에 '홍길동' in person은 False를 반환한다.
# 한 줄 요약: 딕셔너리의 in 연산은 [키]값만 조회함.


# person = {'이름': '홍길동', '나이': 26, '몸무게': 82}
# len(person) # 딕셔너리 항목의 개수를 반환

# print('이름' in person) # '이름'은 키에 있음, # 출력: True
# print('직업' in person) # '직업'은 키에 없음, # 출력: False
# print('홍길동' in person) # '홍길동'은 값에 있으나 키에 없음 (주의), # 출력: False

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# in연산자를 이용한 항목의 존재여부 조회


# print('apple' in ['orange', 'apple', 'mango']) # ['orange', 'apple', 'mango'] 내에 'apple'가 있는지 조회

# print('x' in 'aeiou') # 'x'가 'aeiou' 내에 있는지 조회

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 딕셔너리의 비교 연산

# # '이름', '나이'를 키로 갖는 딕셔너리 d1 생성
# d1 = {'이름': '홍길동', '나이': 26}
# # '나이', '이름'을 키로 갖는 딕셔너리 d2 생성. d1과 키의 순서가 다름.
# d2 = {'나이': 26, '이름': '홍길동'}

# # 딕셔너리 d1과 d2가 동일한지 비교. 키와 값이 동일하면 True, 아니면 False
# print(d1 == d2)  # 결과: True

# print(d1 > d2) # 딕셔너리에서는 >, >=, <, <= 와 같은 비교연산은 지원하지 않음, # 결과: 오류

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# LAB 6-3: 딕셔너리와 연산


# # 국가명을 키로, 수도명을 값으로 갖는 딕셔너리 생성
# capital_dic = {'korea': 'seoul', 'china': 'beijing', 'usa': 'washington dc'}

# # 'korea'라는 키가 딕셔너리에 존재하는지 확인: True
# print('korea' in capital_dic)
# # 'china'라는 키가 딕셔너리에 존재하는지 확인: True
# print('china' in capital_dic)
# # 'indonesia'라는 키가 딕셔너리에 존재하는지 확인: False
# print('indonesia' in capital_dic)
# # 'beijing'라는 키가 딕셔너리에 존재하는지 확인: False (주의: 'beijing'은 값이지 키가 아님)
# print('beijing' in capital_dic)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 딕셔너리의 메소드


# ex_dic = {'ex_key': 'ex_value'}

# ex_dic.keys() # 딕셔너리 내의 모든 키를 반환한다.
# ex_dic.values() # 딕셔너리 내의 모든 값을 반환한다.
# ex_dic.items() # 딕셔너리 내의 모든 항목을 [키]:[값] 쌍으로 반환한다.
# ex_dic.get(key) # 키에 대한 값을 반환한다. 키가 없으면 None을 반환한다.
# ex_dic.pop(key) # 키에 대한 값을 반환하고, 그 항목을 삭제한다. 키가 없으면 KeyError가 발생한다.
# ex_dic.popitem() # 마지막으로 입력된 항목을 반환하고 그 항목을 삭제한다.
# ex_dic.clear() # 딕셔너리 내의 모든 항목을 삭제한다.

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 딕셔너리의 keys(), values(), items() 메소드


# person = {'이름': '홍길동', '나이': 26, '몸무게': 82}

# print(person.keys()) # 출력: dict_keys(['이름', '나이', '몸무게'])
# print(person.values()) # 출력: dict_values(['홍길동', 26, 82])
# print(person.items()) # 출력: dict_items([('이름', '홍길동'), ('나이', 26), ('몸무게', 82)])

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 딕셔너리의 get() 메소드


# person = {'이름': '홍길동', '나이': 26, '몸무게': 82}
# print(person['취미']) # '취미' 키가 없으므로 여기서는 예외를 발생시킴

# print(person.get('취미')) # '취미' 키가 없으므로 None을 반환함
# print(person.get('이름'))

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 파이썬의 None 키워드


# 파이썬은 None이라는 키워드를 제공하는데 이 값은 널 값이나 아무 값이 없을 때 사용하는 키워드이다. 0이나 False와 같은 값을 이용하여 '아무 값 없음'을 표현할 수 있을 것 같지만 이 값들은 엄연한 객체이며 변수가 '아무런 값도 가지지 않음'을 표현하는 유일한 방법은 None을 할당하는 방법이다.

# x = None

# 따라서 위의 코드를 다음과 같이 수정하면 None을 출력한다.

# x = person.get('취미') # '취미' 키가 없으므로 None을 반환함
# print(x)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# # 딕셔너리의 값들을 리스트로 변환
# print(list(fruit_prices.values()))  # 값 리스트 출력

# # 딕셔너리의 길이(키-값 쌍의 개수) 출력
# print(len(fruit_prices))

# # "apple"이 딕셔너리의 키 중 하나인지 확인
# print("apple" in fruit_prices.keys())  # 결과 출력 (True 또는 False)

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# # 튜플 생성
# my_tuple = (1, 2, 3, 4, 5)

# # 튜플의 첫 번째 요소 출력
# print(my_tuple[0])

# # 튜플의 두 번째 요소 출력
# print(my_tuple[1])

# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


# ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 6.24

# x = 'ATTACK TONIGHT!'
# key = 3

# for ch in x:
#     if ch>='A' and ch<='Z':
#         Value = ord(ch)+key
#         if Value > 90:
#             Value = Value - 91 + 65
#         print(chr(Value))
#     else:
#         print(ch)
